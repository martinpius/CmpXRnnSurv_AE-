# -*- coding: utf-8 -*-
"""Complex_surv_Eval_metric

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KaLFUwWAAxNVhHAnOiLiH_qJjklDeLL1
"""

import numpy as np

def time_dependent_C_index(preds,surv_time,labels,horizon):
  """
  @Author: Martin Pius
  ----------------------
  -This module compute the time dependent concordance index to
  evaluate the performance of the Complex_surv model.

  Parameters:
  ------------
  preds: np.array, Predictions from the model ==:> shape [B,]
  surv_time: np.array, survival times ==:> shape [B,]
  labels:np.array, Indicator for the events and censore observations
  horizon: Float, time stamp which prediction is based

  Return:
  -------
  Ct_index: Float, time dependent concordance index

  """
  assert preds.shape[0] == suv_time.shape[0] # Must be of the same shape
  B = preds.shape[0]
  mask1 = np.zeros((B, B)) # mask to compare individual survival time accross time stamps [Ti < Tj])
  mask2 = np.zeros((B, B)) # mask to capture individual risks across time stamps [Fi > Fj]
  mask3 = np.zeros((B, B)) # mask to filter individuals who developed event of interest
  Numerator = 0
  Denominator = 0
  for i in range(B):
    mask1[i, np.where(suv_time[i] < suv_time)] = 1 # compare every individual survival across time steps
    mask2[i, np.where(preds[i] > preds)] = 1 # compare every individual risk accross time steps
    if (suv_time[i] <= horizon and labels[i]==1): #capture event of interest only
      mask3[i,:] = 1
  Numerator  = np.sum(((mask1) * mask3)*mask2) # compute number of individuals who have P([Fi > Fj] / [Ti < Tj])
  Denominator = np.sum((mask2)* mask3) # compute total number of posible events
  if Numerator == 0 and Denominator == 0:
    Ct_index  = -1
  else:
    Ct_index = (Numerator/Denominator)

  return Ct_index



def __MAE__(pred, suv_time, labels, horizon):
  """
  @Author: Martin Pius
  --------------------
  This method compute the mean absolute error for the predictions (Brier-score)

  parameters:
  ------------
  preds: np.array, Predictions from the model ==:> shape [B,]
  surv_time: np.array, survival times ==:> shape [B,]
  labels:np.array, Indicator for the events and censore observations
  horizon: Float, time stamp which prediction is based

  Return:
  -------
  MAE: Float
  """
  assert pred.shape[0] == suv_time.shape[0] # Must be of the same shape
  B = pred.shape[0]
  target = ((suv_time <= horizon) * labels).astype(float)
  pred = ((pred <= horizon) * labels).astype(float)
  mae = np.mean(np.abs(target - pred))
  return mae

#----------- x ------------ sanity check for the Ct_index  and MAE ------------- x ----------------#

pred = np.array([60,20,30,40,50,20,70,80])
suv_time = np.array([20,20,30,40,50,60,20,80])
labels = np.array([1,1,0,2,1,0,2,0])
horizon = 20

Ct_index = time_dependent_C_index(pred, suv_time, labels, horizon)
mae = __MAE__(pred, suv_time, labels, horizon)

print(f">>>> The Ct_index at time {horizon} is: {Ct_index:.2f} and the MAE is {mae:.3f}")

